# 🎭 الگوی طراحی State — تغییر رفتار بر اساس وضعیت

الگوی State یکی از الگوهای رفتاری در طراحی نرم‌افزار است که اجازه می‌دهد رفتار یک شیء بسته به وضعیت داخلی‌اش تغییر کند، بدون اینکه ساختار کلاس یا منطق کلی آن تغییر یابد.

---

## 🧩 مسئله‌ای که حل می‌کند

وقتی شیء ما چندین وضعیت مختلف دارد و رفتار آن در هر وضعیت متفاوت است، معمولاً از شرط‌هایی مثل `if/else` یا `switch` استفاده می‌کنیم. این روش در پروژه‌های بزرگ کد را ناخوانا و گسترش آن را سخت می‌کند.

---

## 🧠 راه‌حل State

در این الگو، به‌جای استفاده از شرط‌های متعدد، **هر وضعیت را در یک کلاس جداگانه پیاده‌سازی می‌کنیم** که رفتار مختص آن وضعیت را دارد. سپس شیء اصلی (Context) به‌جای بررسی شرط، فقط وضعیت فعلی خود را عوض می‌کند.

---

## 🧱 اجزای اصلی الگو:

1. **Context**: شیء اصلی که وضعیت فعلی را نگه می‌دارد و عملیات‌ها را به وضعیت فعلی واگذار می‌کند.
2. **State Interface**: رابط مشترک میان همه وضعیت‌ها.
3. **Concrete States**: پیاده‌سازی‌های خاص هر وضعیت که رفتار خاص خود را دارند.

---

## 🛠 مثال TypeScript ساده:

```ts
interface State {
  handle(): void;
}

class HappyState implements State {
  handle() {
    console.log("من خوشحالم!");
  }
}

class SadState implements State {
  handle() {
    console.log("من ناراحتم...");
  }
}

class Person {
  private state: State;

  constructor(state: State) {
    this.state = state;
  }

  setState(state: State) {
    this.state = state;
  }

  talk() {
    this.state.handle();
  }
}

const person = new Person(new HappyState());
person.talk(); // من خوشحالم!
person.setState(new SadState());
person.talk(); // من ناراحتم...
```

---

## ✅ مزایای الگو:

- حذف شرط‌های زیاد
- سهولت در توسعه و نگهداری
- افزودن وضعیت جدید فقط با اضافه‌کردن یک کلاس

## ❌ معایب:

- افزایش تعداد کلاس‌ها
- ممکن است برای پروژه‌های کوچک بیش از حد پیچیده به‌نظر برسد

---

## 🔚 نتیجه‌گیری:

الگوی State یک ابزار بسیار مفید برای زمانی است که رفتار شیء ما به وضعیت آن بستگی دارد. اگر کد شما پر از شرط برای مدیریت حالت‌های مختلف است، این الگو به کمک شما خواهد آمد.
