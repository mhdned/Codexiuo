# مشکل چیه اصلاً؟

اگه زمان زیادی با JavaScript، لایبرری‌ها و فریم‌ورک‌هاش گذرونده باشین، احتمالاً به این مشکل برخوردین که async/await برای **array method**‌های داخل این زبان فقط یه شوخی چندشه.

این methodها نه به این keyword محل می‌ذارن، نه تحویلش می‌گیرن. در خوش‌بینانه‌ترین حالت، با نگاه تأمل‌برانگیزشون می‌گن: «کی اینو راه داد اینجا؟»

خب بریم سر اصل مطلب. امروز توی مصاحبه کاری که داشتم، ازم پرسیده شد که وقتی برای انجام عملیات یا function داخل حلقه‌هایی مثل `for`، `forEach`، `map` و غیره بیایم از `await` استفاده کنیم، مشکلی توی خروجی ایجاد می‌شه یا نه؟

واقعیتش اینه که من درست جواب دادم، ولی مصاحبه‌کننده زیاد حرفمو قبول نداشت. شاید چون روشی که برای حل مشکل انتخاب کرده بودم، زیاد جذاب نبود—بیشتر شبیه از زیر کار در رفتن بود. اما به هر حال، جواب من درست بود.

وقتی از `await` داخل array methodها استفاده می‌کنیم، به یه مشکلی می‌خوریم و اون اینکه `await` هیچ تأثیری در **asynchronous programming** نداره.

بریم علتش رو بررسی کنیم.

---

## مشکل asynchronous (async/await) در array methods (forEach, map, filter, etc.)

```js
items.forEach(async (item) => {
  await doSomethingAsync(item);
});
```

این مشکل به نحوه‌ی رفتار این توابع در پیمایش iterableها برمی‌گرده. این توابع به‌صورت پیش‌فرض asynchronous نیستن و منتظر پایان کارهای async نمی‌مونن.

این مثال رو اجرا کنید و به خروجی که می‌گیرید یه نگاهی بندازید. جالبه:

```js
const items = [1, 2, 3, 4];

items.forEach(async (item) => {
  console.log(item);
  await new Promise((resolve) => setTimeout(resolve, 1000));
  console.log("Done:", item);
});

console.log("End of loop");
```

توی این مثال، حلقه اصلاً منتظر این نمی‌مونه که log مربوط به setTimeout اجرا بشه. ابتدا اعداد ۱ تا ۴ رو log می‌کنه و بعد از چاپ 'End of loop' می‌ره سراغ چاپ مقدارهای مربوط به `setTimeout`. این موضوع از این‌جا نشئت می‌گیره که:

در جاوااسکریپت وقتی از `async` درون callback استفاده می‌کنیم، هر بار که `await` فراخوانی می‌شه، یک `Promise` برمی‌گرده که باید منتظر حل شدنش بمونیم. اما `forEach` هیچ‌وقت منتظر این Promiseها نمی‌مونه و مستقیم می‌ره سراغ عنصر بعدی.

---

## راه حل: دشوار نیست یا می‌تونه جالب باشه

در اولین روش، می‌تونید عقل سلیم رو مرجع قرار بدید و بگید: اگه `forEach` نشد، شاید `for` بشه. اون موقع‌ست که نتیجه می‌گیرید. اگه بی‌دلیل فقط به صرف اینکه "for کار می‌کنه، پس دیگه تسک asynchronous رو با forEach نمی‌زنم." تبریک می‌گم! شما در پوزیشن دِولوپر و در سطح بنا (ماله‌کش کد؛ کسی که بهتره مهندس خطاب نشه) قرار می‌گیرید.

```js
for (let item of items) {
  await doSomethingAsync(item);
}
```

اما اگه مریضی مُسری داشتید و خواستید حتماً با array methodها کارتونو راه بندازید، اینم راه‌حل دوم. نمی‌گم بهتره یا خیلی performance بالاتری ارائه می‌ده—بسته به سناریویی که دارید، راه‌حل مناسب‌ رو انتخاب کنید. استفاده از `Promise.all` برای asynchronous شدن array methodها:

```js
await Promise.all(items.map(item => doSomethingAsync(item)))
```

